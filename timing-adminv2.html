<!DOCTYPE html>
<html lang="zh-HK">
<head>
  <meta charset="UTF-8">
  <title>ğŸ“Š NFC è¨ˆæ™‚å¾Œå°</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: -apple-system, BlinkMacSystemFont, sans-serif; 
      background: #ffffff; /* æ”¹ä¸ºç™½è‰²èƒŒæ™¯ */
      color: #000000; /* æ”¹ä¸ºé»‘è‰²æ–‡å­— */
      padding: 20px; 
    }
    .container { max-width: 1200px; margin: 0 auto; }
    .header { background: white; padding: 24px; border-radius: 16px; margin-bottom: 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
    input { padding: 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 16px; width: 300px; margin-right: 12px; }
    button { padding: 12px 24px; background: #3b82f6; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; }
    button:hover { background: #2563eb; }
    .controls { margin: 20px 0; }
    .mode-toggle { display: inline-block; margin-right: 20px; font-size: 18px; font-weight: bold; }
    .mode-btn { padding: 8px 16px; margin: 0 4px; border: none; border-radius: 20px; cursor: pointer; font-weight: bold; }
    .active { background: #10b981; color: white; }
    table { width: 100%; border-collapse: collapse; background: white; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
    th, td { padding: 16px; text-align: left; border-bottom: 1px solid #e2e8f0; }
    th { background: #f1f5f9; font-weight: bold; }
    .gold { background: #fef3c7; } .silver { background: #e0f2fe; } .bronze { background: #fed7aa; }
    #log { background: #f8f9fa; padding: 20px; border-radius: 12px; max-height: 200px; overflow-y: auto; font-family: monospace; color: #000000; }
    .dashboard { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin-bottom: 24px; }
    .stat-card { background: white; padding: 24px; border-radius: 16px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); text-align: center; }
    .stat-number { font-size: 36px; font-weight: bold; color: #3b82f6; }
    .stat-label { color: #64748b; margin-top: 8px; }
    .chart-container { background: white; padding: 24px; border-radius: 16px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); margin-bottom: 24px; width: 25%; margin-left: auto; margin-right: auto; }
    
    /* å¯¼èˆªæ ·å¼ */
    .navigation { margin-bottom: 20px; border-bottom: 1px solid #e2e8f0; padding-bottom: 10px; }
    .nav-btn { padding: 8px 16px; margin-right: 10px; background: #f1f5f9; color: #000000; }
    .nav-btn.active { background: #3b82f6; color: white; }
    
    /* é¡µé¢å®¹å™¨æ ·å¼ */
    .page { display: none; }
    .page.active { display: block; }
    
    /* ç­›é€‰å™¨æ ·å¼ */
    .filters { margin: 16px 0; padding: 16px; background: #f8fafc; border-radius: 8px; }
    select, .filter-input { padding: 8px 12px; margin-right: 12px; border: 1px solid #e2e8f0; border-radius: 4px; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>ğŸ“Š NFC è·‘æ‰‹è¨ˆæ™‚å¾Œå°</h1>
      <div>
        <input id="adminUrl" placeholder="https://wceywyxwyygbwfodjdpp.supabase.co" value="https://vzulldiiuguzobjcpikh.supabase.co" style="display: none;">
        <input id="adminKey" placeholder="sb_publishable_BWBxXzGk8bRGql3VbkCqbA_IZOfH5rc" type="password" value="sb_publishable_SBltOg1AOREur1bYWij2kg_BneOwzh4" style="display: none;">
        <button onclick="connectAdmin()">ğŸ”— é€£ç·šå¾Œå°</button>
        <button onclick="exportCSV()" style="background: #10b981; float: right; margin-left: 8px;">ğŸ’¾ åŒ¯å‡º CSV</button>
        <button onclick="showManageUsersModal()" style="background: #6366f1; float: right; margin-left: 8px;">ğŸ‘¥ ç®¡ç†åƒè³½è€…</button>
        <button onclick="clearAllData()" style="background: #ef4444; float: right;">ğŸ—‘ï¸ æ¸…ç©ºæ•¸æ“š</button>
      </div>
      <div id="status" style="margin-top: 12px; padding: 8px; border-radius: 8px; font-weight: bold;">æœªé€£ç·š</div>
    </div>
    
    <!-- é¡µé¢å¯¼èˆª -->
    <div class="navigation" id="navigation" style="display: none;">
      <button class="nav-btn active" onclick="showPage('overview')">æ€»è§ˆ</button>
      <button class="nav-btn" onclick="showPage('ranking')">æ’åè¯¦æƒ…</button>
      <button class="nav-btn" onclick="showPage('checkins')">æ‰“å¡è®°å½•</button>
    </div>
    
    <!-- æ€»è§ˆé¡µé¢ -->
    <div id="overview-page" class="page active">
      <div class="dashboard" id="dashboard" style="display: none;">
        <div class="stat-card">
          <div class="stat-number" id="totalRunners">0</div>
          <div class="stat-label">ç¸½åƒè³½äººæ•¸</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="startedRunners">0</div>
          <div class="stat-label">å·²å‡ºç™¼äººæ•¸</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="finishedRunners">0</div>
          <div class="stat-label">å·²å®Œè³½äººæ•¸</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="avgTime">00:00</div>
          <div class="stat-label">å¹³å‡å®Œè³½æ™‚é–“</div>
        </div>
      </div>
      
      <div class="chart-container" id="progressChart" style="display: none;">
        <h3>ğŸ“ˆ æ¯”è³½é€²åº¦</h3>
        <canvas id="progressChartCanvas" width="400" height="200"></canvas>
      </div>
      
      <div class="controls">
        <div class="mode-toggle">
          ğŸ† æ’åæ¨¡å¼: 
          <button class="mode-btn active" onclick="setMode('gun', event)">ğŸ¯ çµ‚é»å…ˆå¾Œ</button>
          <button class="mode-btn" onclick="setMode('chip', event)">â±ï¸ å¯¦éš›ç”¨æ™‚</button>
          <button class="mode-btn" onclick="setMode('split', event)">ğŸ“Š åˆ†æ®µæˆç¸¾</button>
        </div>
        <button onclick="refreshData()">ğŸ”„ åˆ·æ–°è³‡æ–™</button>
      </div>
      
      <table id="resultsTable">
        <thead>
          <tr>
            <th>æ’å</th>
            <th>è™Ÿç¢¼</th>
            <th>å§“å</th>
            <th>èµ·è·‘æ™‚é–“</th>
            <th>å®Œè³½æ™‚é–“</th>
            <th>ç”¨æ™‚</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    
    <!-- æ’åè¯¦æƒ…é¡µ -->
    <div id="ranking-page" class="page">
      <h2>ğŸ† æ’åè¯¦æƒ…</h2>
      <div class="filters">
        <select id="rankingCheckpointFilter" onchange="refreshData()">
          <option value="all">æ‰€æœ‰æ£€æŸ¥ç‚¹</option>
          <!-- åŠ¨æ€å¡«å……æ£€æŸ¥ç‚¹é€‰é¡¹ -->
        </select>
        <button onclick="refreshData()">ğŸ”„ åˆ·æ–°æ’å</button>
      </div>
      <div class="mode-toggle">
        æ’åæ¨¡å¼: 
        <button class="mode-btn active" onclick="setMode('gun', event)">ğŸ¯ æŒ‰ç»ˆç‚¹æ—¶é—´</button>
        <button class="mode-btn" onclick="setMode('chip', event)">â±ï¸ æŒ‰å®é™…ç”¨æ—¶</button>
        <button class="mode-btn" onclick="setMode('split', event)">ğŸ“Š æŒ‰åˆ†æ®µæˆç»©</button>
      </div>
      <table id="detailedRankingTable">
        <thead>
          <tr>
            <th>æ’å</th>
            <th>è™Ÿç¢¼</th>
            <th>å§“å</th>
            <th>å„æ£€æŸ¥ç‚¹æ—¶é—´</th>
            <th>æ€»ç”¨æ—¶</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    
    <!-- æ‰“å¡è®°å½•é¡µ -->
    <div id="checkins-page" class="page">
      <h2>ğŸ“ æ‰“å¡è®°å½•</h2>
      <div class="filters">
        <select id="checkpointFilter" onchange="filterCheckins()">
          <option value="all">æ‰€æœ‰æ£€æŸ¥ç‚¹</option>
          <!-- åŠ¨æ€å¡«å……æ£€æŸ¥ç‚¹é€‰é¡¹ -->
        </select>
        <input type="text" id="bibFilter" placeholder="æœç´¢å·ç " class="filter-input" oninput="filterCheckins()">
        <button onclick="refreshData()">ğŸ”„ åˆ·æ–°è®°å½•</button>
      </div>
      <table id="checkinsTable">
        <thead>
          <tr>
            <th>æ—¶é—´</th>
            <th>è™Ÿç¢¼</th>
            <th>å§“å</th>
            <th>æ£€æŸ¥ç‚¹</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    
    <div style="margin-top: 24px;">
      <h3>ğŸ“ æœ€æ–°æ‰“å¡è¨˜éŒ„</h3>
      <div id="log"></div>
    </div>
  </div>

  <!-- ç®¡ç†åƒè³½è€…æ¨¡æ…‹æ¡† -->
  <div id="manageUsersModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center;">
    <div style="background: white; border-radius: 16px; padding: 32px; max-width: 800px; width: 90%; max-height: 80vh; overflow-y: auto;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
        <h2>ğŸ‘¥ ç®¡ç†åƒè³½è€…</h2>
        <button onclick="hideManageUsersModal()" style="background: #64748b; padding: 8px 16px;">âœ• é—œé–‰</button>
      </div>
      
      <!-- æ£€æŸ¥ç‚¹é…ç½® -->
      <div style="margin-bottom: 24px; padding: 20px; background: #f8fafc; border-radius: 12px;">
        <h3>ğŸš© æ£€æŸ¥ç‚¹é…ç½®</h3>
        <p style="margin-bottom: 16px;">è®¾ç½®æœ¬æ¬¡æ¯”èµ›çš„æ£€æŸ¥ç‚¹ï¼ˆæœ€å°‘2ä¸ªï¼Œæœ€å¤š10ä¸ªï¼‰</p>
        
        <div style="margin-bottom: 16px;">
          <label>æ£€æŸ¥ç‚¹æ•°é‡ï¼š</label>
          <input type="number" id="checkpointCount" min="2" max="10" value="2" style="width: 80px;">
          <button onclick="updateCheckpointFields()" style="background: #3b82f6;">æ›´æ–°æ•°é‡</button>
        </div>
        
        <div id="checkpointFields">
          <!-- åŠ¨æ€ç”Ÿæˆæ£€æŸ¥ç‚¹é…ç½®å­—æ®µ -->
          <div class="checkpoint-field" style="display: flex; gap: 12px; margin-bottom: 8px;">
            <input placeholder="ä»£ç ï¼ˆå¦‚STARTï¼‰" style="width: 120px;" value="START">
            <input placeholder="åç§°ï¼ˆå¦‚èµ·ç‚¹ï¼‰" style="flex: 1;" value="èµ·ç‚¹">
            <input type="number" placeholder="é¡ºåº" style="width: 80px;" value="1">
            <label style="margin-top: 12px;">å¿…è¿‡: <input type="checkbox" checked></label>
          </div>
          <div class="checkpoint-field" style="display: flex; gap: 12px; margin-bottom: 8px;">
            <input placeholder="ä»£ç ï¼ˆå¦‚FINISHï¼‰" style="width: 120px;" value="FINISH">
            <input placeholder="åç§°ï¼ˆå¦‚ç»ˆç‚¹ï¼‰" style="flex: 1;" value="ç»ˆç‚¹">
            <input type="number" placeholder="é¡ºåº" style="width: 80px;" value="2">
            <label style="margin-top: 12px;">å¿…è¿‡: <input type="checkbox" checked></label>
          </div>
        </div>
        
        <button onclick="saveCheckpointConfigs()" style="background: #22c55e;">ä¿å­˜æ£€æŸ¥ç‚¹é…ç½®</button>
      </div>
      
      <!-- CSV å°å…¥åŠŸèƒ½ -->
      <div style="margin-bottom: 24px; padding: 20px; background: #f8fafc; border-radius: 12px;">
        <h3>ğŸ“ å¾ CSV å°å…¥åƒè³½è€…</h3>
        <p style="color: #64748b; margin-bottom: 16px;">CSV æ ¼å¼ï¼šè™Ÿç¢¼,å§“åï¼ˆä¾‹å¦‚ï¼š001,å¼µä¸‰ï¼‰</p>
        <input type="file" id="csvFileInput" accept=".csv" style="margin-bottom: 16px;">
        <button onclick="importFromCSV()" style="background: #22c55e;">ğŸ“¥ å°å…¥ CSV</button>
        <div id="csvImportStatus" style="margin-top: 16px; font-family: monospace;"></div>
      </div>
      
      <!-- æ‰‹å‹•æ·»åŠ åƒè³½è€… -->
      <div style="margin-bottom: 24px; padding: 20px; background: #f8fafc; border-radius: 12px;">
        <h3>â• æ‰‹å‹•æ·»åŠ åƒè³½è€…</h3>
        <div style="display: flex; gap: 12px; margin-bottom: 16px;">
          <input id="manualBibNumber" placeholder="è™Ÿç¢¼ï¼ˆå¦‚ï¼š001ï¼‰" style="width: 150px;">
          <input id="manualName" placeholder="å§“å" style="flex: 1;">
          <button onclick="addSingleUser()" style="background: #3b82f6;">â• æ·»åŠ </button>
        </div>
      </div>
      
      <!-- åƒè³½è€…åˆ—è¡¨ -->
      <div>
        <h3>ğŸ“‹ åƒè³½è€…åˆ—è¡¨</h3>
        <div style="max-height: 300px; overflow-y: auto; border: 1px solid #e2e8f0; border-radius: 8px;">
          <table id="participantsTable" style="width: 100%; border-radius: 8px;">
            <thead>
              <tr>
                <th style="padding: 12px; text-align: left; border-bottom: 1px solid #e2e8f0; background: #f1f5f9;">è™Ÿç¢¼</th>
                <th style="padding: 12px; text-align: left; border-bottom: 1px solid #e2e8f0; background: #f1f5f9;">å§“å</th>
                <th style="padding: 12px; text-align: center; border-bottom: 1px solid #e2e8f0; background: #f1f5f9;">æ“ä½œ</th>
              </tr>
            </thead>
            <tbody id="participantsTableBody">
              <!-- åƒè³½è€…æ•¸æ“šå°‡å‹•æ…‹åŠ è¼‰ -->
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <script>
    let adminClient = null;
    let rankingMode = 'gun';
    let progressChart = null;
    let checkpoints = []; // å­˜å‚¨æ£€æŸ¥ç‚¹é…ç½®

    // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨è¿æ¥
    window.addEventListener('DOMContentLoaded', () => {
      // å°è¯•ä»æœ¬åœ°å­˜å‚¨è·å–è¿æ¥ä¿¡æ¯
      const savedUrl = localStorage.getItem('nfc_admin_url');
      const savedKey = localStorage.getItem('nfc_admin_key');
      
      if (savedUrl && savedKey) {
        document.getElementById('adminUrl').value = savedUrl;
        document.getElementById('adminKey').value = savedKey;
        setTimeout(() => connectAdmin(), 1000); // å»¶è¿Ÿ1ç§’è‡ªåŠ¨è¿æ¥
      }
    });

    // é¡µé¢åˆ‡æ¢åŠŸèƒ½
    function showPage(pageId) {
      // éšè—æ‰€æœ‰é¡µé¢
      document.querySelectorAll('.page').forEach(page => {
        page.classList.remove('active');
      });
      
      // æ˜¾ç¤ºé€‰ä¸­é¡µé¢
      document.getElementById(`${pageId}-page`).classList.add('active');
      
      // æ›´æ–°å¯¼èˆªæŒ‰é’®çŠ¶æ€
      document.querySelectorAll('.nav-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      event.target.classList.add('active');
      
      // åŠ è½½å¯¹åº”é¡µé¢æ•°æ®
      if (pageId === 'ranking') {
        loadRankingData();
      } else if (pageId === 'checkins') {
        loadCheckinsData();
      } else {
        refreshData();
      }
    }

    // æ£€æŸ¥ç‚¹é…ç½®ç›¸å…³å‡½æ•°
    function updateCheckpointFields() {
      const count = parseInt(document.getElementById('checkpointCount').value);
      const container = document.getElementById('checkpointFields');
      container.innerHTML = '';
      
      for (let i = 1; i <= count; i++) {
        const code = i === 1 ? 'START' : i === count ? 'FINISH' : `CP${i-1}`;
        const name = i === 1 ? 'èµ·ç‚¹' : i === count ? 'ç»ˆç‚¹' : `æ£€æŸ¥ç‚¹${i-1}`;
        
        const field = document.createElement('div');
        field.className = 'checkpoint-field';
        field.style = 'display: flex; gap: 12px; margin-bottom: 8px;';
        field.innerHTML = `
          <input placeholder="ä»£ç " style="width: 120px;" value="${code}">
          <input placeholder="åç§°" style="flex: 1;" value="${name}">
          <input type="number" placeholder="é¡ºåº" style="width: 80px;" value="${i}">
          <label style="margin-top: 12px;">å¿…è¿‡: <input type="checkbox" ${i === 1 || i === count ? 'checked' : ''}></label>
        `;
        container.appendChild(field);
      }
    }

    async function saveCheckpointConfigs() {
      if (!adminClient) {
        alert('è¯·å…ˆè¿æ¥æ•°æ®åº“');
        return;
      }
      
      const fields = document.querySelectorAll('.checkpoint-field');
      const configs = Array.from(fields).map((field, index) => {
        const inputs = field.querySelectorAll('input');
        return {
          code: inputs[0].value,
          name: inputs[1].value,
          order_index: parseInt(inputs[2].value),
          is_required: inputs[3].checked,
          event_id: 'default' // é»˜è®¤ä¸ºå½“å‰èµ›äº‹
        };
      });
      
      // å…ˆåˆ é™¤ç°æœ‰é…ç½®
      const { error: deleteError } = await adminClient
        .from('checkpoint_configs')
        .delete()
        .eq('event_id', 'default');
      
      if (deleteError) {
        alert('åˆ é™¤æ—§é…ç½®å¤±è´¥: ' + deleteError.message);
        return;
      }
      
      // ä¿å­˜æ–°é…ç½®
      const { error } = await adminClient
        .from('checkpoint_configs')
        .insert(configs);
      
      if (error) {
        alert('ä¿å­˜æ£€æŸ¥ç‚¹é…ç½®å¤±è´¥: ' + error.message);
      } else {
        alert('æ£€æŸ¥ç‚¹é…ç½®å·²ä¿å­˜');
        await loadCheckpoints(); // é‡æ–°åŠ è½½æ£€æŸ¥ç‚¹é…ç½®
        refreshData(); // åˆ·æ–°æ‰€æœ‰æ•°æ®
      }
    }

    // åŠ è½½æ£€æŸ¥ç‚¹é…ç½®
    async function loadCheckpoints() {
      if (!adminClient) return;
      
      const { data, error } = await adminClient
        .from('checkpoint_configs')
        .select('*')
        .eq('event_id', 'default')
        .order('order_index');
      
      if (error) {
        console.error('åŠ è½½æ£€æŸ¥ç‚¹é…ç½®å¤±è´¥:', error);
        // ä½¿ç”¨é»˜è®¤é…ç½®
        checkpoints = [
          { code: 'START', name: 'èµ·ç‚¹', order_index: 1, is_required: true },
          { code: 'FINISH', name: 'ç»ˆç‚¹', order_index: 2, is_required: true }
        ];
      } else {
        checkpoints = data.length > 0 ? data : [
          { code: 'START', name: 'èµ·ç‚¹', order_index: 1, is_required: true },
          { code: 'FINISH', name: 'ç»ˆç‚¹', order_index: 2, is_required: true }
        ];
      }
      
      // æ›´æ–°æ£€æŸ¥ç‚¹ç­›é€‰å™¨
      updateCheckpointFilters();
    }

    // æ›´æ–°æ£€æŸ¥ç‚¹ç­›é€‰å™¨é€‰é¡¹
    function updateCheckpointFilters() {
      const filters = [
        document.getElementById('checkpointFilter'),
        document.getElementById('rankingCheckpointFilter')
      ];
      
      filters.forEach(filter => {
        if (!filter) return;
        
        // ä¿å­˜å½“å‰é€‰ä¸­å€¼
        const currentValue = filter.value;
        
        // æ¸…é™¤ç°æœ‰é€‰é¡¹ï¼ˆä¿ç•™"æ‰€æœ‰æ£€æŸ¥ç‚¹"ï¼‰
        while (filter.options.length > 1) {
          filter.remove(1);
        }
        
        // æ·»åŠ æ£€æŸ¥ç‚¹é€‰é¡¹
        checkpoints.forEach(checkpoint => {
          const option = document.createElement('option');
          option.value = checkpoint.code;
          option.textContent = checkpoint.name;
          filter.appendChild(option);
        });
        
        // æ¢å¤é€‰ä¸­å€¼
        if (currentValue) {
          filter.value = currentValue;
        }
      });
    }

    // âœ… é€£ç·šå¾Œå°
    async function connectAdmin() {
      const url = document.getElementById('adminUrl').value.trim();
      const key = document.getElementById('adminKey').value.trim();
      const status = document.getElementById('status');

      try {
        if (!url || !key) {
          alert('URL æˆ– Key ç„¡å¡«');
          return;
        }

        // ä¿å­˜è¿æ¥ä¿¡æ¯åˆ°æœ¬åœ°å­˜å‚¨
        localStorage.setItem('nfc_admin_url', url);
        localStorage.setItem('nfc_admin_key', key);

        adminClient = window.supabase.createClient(url, key);

        status.textContent = 'é€£ç·šä¸­...';
        status.style.background = '#f59e0b';

        // æµ‹è¯•è¿æ¥
        const { data, error } = await adminClient
          .from('participants')
          .select('*')
          .limit(1);

        if (error) {
          throw new Error('è®€å– participants å‡ºéŒ¯ï¼š' + error.message);
        }

        status.textContent = 'âœ… å¾Œå°å·²é€£ç·š';
        status.style.background = '#10b981';

        // æ˜¾ç¤ºå¯¼èˆªå’Œä»ªè¡¨æ¿
        document.getElementById('navigation').style.display = 'block';
        document.getElementById('dashboard').style.display = 'grid';
        document.getElementById('progressChart').style.display = 'block';

        // åŠ è½½æ£€æŸ¥ç‚¹é…ç½®
        await loadCheckpoints();
        
        // è¿æ¥æˆåŠŸåï¼ŒåŠ è½½æ•°æ®
        await refreshData();

      } catch (e) {
        console.error('è¿æ¥é”™è¯¯:', e);
        status.textContent = 'âŒ é€£ç·šå¤±æ•—';
        status.style.background = '#ef4444';
        alert('å¾Œå°é€£ç·šå¤±æ•—ï¼š' + (e.message || e.toString()));
      }
    }

    // âœ… åˆ·æ–°è³‡æ–™
    async function refreshData() {
      if (!adminClient) {
        alert('è«‹å…ˆé€£ç·šå¾Œå°');
        return;
      }

      try {
        // è·å–æ‰€æœ‰äº‹ä»¶æ•°æ®
        const { data: events, error: e1 } = await adminClient
          .from('events')
          .select('*')
          .order('timestamp', { ascending: true });
        
        if (e1) throw new Error('è®€ events å‡ºéŒ¯ï¼š' + e1.message);

        // è·å–æ‰€æœ‰å‚èµ›è€…æ•°æ®
        const { data: participants, error: e2 } = await adminClient
          .from('participants')
          .select('*');
        
        if (e2) throw new Error('è®€ participants å‡ºéŒ¯ï¼š' + e2.message);

        // æ˜¾ç¤ºç»“æœå’Œæ—¥å¿—
        displayResults(events, participants);
        logRecentEvents(events);
        updateDashboard(events, participants);
        updateProgressChart(events, participants);
        
        // å¦‚æœå½“å‰æ˜¾ç¤ºçš„æ˜¯æ’åæˆ–æ‰“å¡è®°å½•é¡µé¢ï¼Œä¹Ÿæ›´æ–°å®ƒä»¬
        if (document.getElementById('ranking-page').classList.contains('active')) {
          loadRankingData();
        }
        if (document.getElementById('checkins-page').classList.contains('active')) {
          loadCheckinsData();
        }

      } catch (e) {
        console.error('åˆ·æ–°æ•°æ®é”™è¯¯:', e);
        alert('åˆ·æ–°æ•¸æ“šå‡ºéŒ¯ï¼š' + e.message);
      }
    }

    // åŠ è½½æ’åè¯¦æƒ…æ•°æ®
    function loadRankingData() {
      if (!adminClient) return;
      
      // è·å–ç­›é€‰æ¡ä»¶
      const checkpointFilter = document.getElementById('rankingCheckpointFilter').value;
      
      // é‡æ–°ä½¿ç”¨ç°æœ‰æ•°æ®åˆ·æ–°æ’åé¡µé¢
      adminClient
        .from('events')
        .select('*')
        .order('timestamp', { ascending: true })
        .then(({ data: events, error: e1 }) => {
          if (e1) throw e1;
          
          return adminClient
            .from('participants')
            .select('*')
            .then(({ data: participants, error: e2 }) => {
              if (e2) throw e2;
              
              // å¤„ç†å¹¶æ˜¾ç¤ºæ’åæ•°æ®
              displayDetailedRanking(events, participants, checkpointFilter);
            });
        })
        .catch(error => {
          console.error('åŠ è½½æ’åæ•°æ®å¤±è´¥:', error);
          alert('åŠ è½½æ’åæ•°æ®å¤±è´¥: ' + error.message);
        });
    }

    // æ˜¾ç¤ºè¯¦ç»†æ’å
    function displayDetailedRanking(events, participants, checkpointFilter) {
      const bibStats = {};

      // åˆå§‹åŒ–æ¯ä¸ªå‚èµ›è€…çš„æ•°æ®
      participants.forEach(participant => {
        bibStats[participant.bib_number] = {
          bib_number: participant.bib_number,
          name: participant.name,
          checkpoints: {},
          total_time: null,
          total_duration: null
        };
      });

      // å¤„ç†äº‹ä»¶æ•°æ®
      events.forEach(event => {
        if (!bibStats[event.bib_number]) return;
        
        // å¦‚æœè®¾ç½®äº†ç­›é€‰å™¨ä¸”ä¸åŒ¹é…ï¼Œåˆ™è·³è¿‡
        if (checkpointFilter !== 'all' && event.checkpoint !== checkpointFilter) {
          return;
        }
        
        bibStats[event.bib_number].checkpoints[event.checkpoint] = {
          timestamp: event.timestamp,
          formatted_time: formatDateTime(event.timestamp)
        };
      });

      // è®¡ç®—æ¯ä¸ªå‚èµ›è€…çš„æ€»æ—¶é—´
      Object.values(bibStats).forEach(runner => {
        // è·å–æŒ‰é¡ºåºæ’åˆ—çš„æ£€æŸ¥ç‚¹
        const orderedCheckpoints = [...checkpoints]
          .sort((a, b) => a.order_index - b.order_index)
          .filter(cp => checkpointFilter === 'all' || cp.code === checkpointFilter);
        
        // æ£€æŸ¥æ˜¯å¦æœ‰èµ·ç‚¹å’Œç»ˆç‚¹è®°å½•
        const firstCheckpoint = orderedCheckpoints[0];
        const lastCheckpoint = orderedCheckpoints[orderedCheckpoints.length - 1];
        
        if (runner.checkpoints[firstCheckpoint.code] && runner.checkpoints[lastCheckpoint.code]) {
          const startTime = new Date(runner.checkpoints[firstCheckpoint.code].timestamp);
          const finishTime = new Date(runner.checkpoints[lastCheckpoint.code].timestamp);
          
          if (finishTime >= startTime) {
            runner.total_duration = finishTime - startTime;
            runner.total_time = formatDuration(runner.total_duration);
          }
        }
      });

      // æ ¹æ®æ’åæ¨¡å¼æ’åº
      let sortedRunners = Object.values(bibStats);
      
      if (rankingMode === 'gun') {
        // æŒ‰ç»ˆç‚¹æ—¶é—´æ’åº
        const lastCheckpoint = checkpoints.sort((a, b) => a.order_index - b.order_index).pop();
        sortedRunners = sortedRunners
          .filter(r => r.checkpoints[lastCheckpoint?.code])
          .sort((a, b) => new Date(a.checkpoints[lastCheckpoint.code].timestamp) - new Date(b.checkpoints[lastCheckpoint.code].timestamp));
      } else if (rankingMode === 'chip') {
        // æŒ‰æ€»ç”¨æ—¶æ’åº
        sortedRunners = sortedRunners
          .filter(r => r.total_duration)
          .sort((a, b) => a.total_duration - b.total_duration);
      } else if (rankingMode === 'split') {
        // æŒ‰å½“å‰ç­›é€‰çš„æ£€æŸ¥ç‚¹æ—¶é—´æ’åº
        if (checkpointFilter !== 'all' && checkpoints.find(cp => cp.code === checkpointFilter)) {
          sortedRunners = sortedRunners
            .filter(r => r.checkpoints[checkpointFilter])
            .sort((a, b) => new Date(a.checkpoints[checkpointFilter].timestamp) - new Date(b.checkpoints[checkpointFilter].timestamp));
        }
      }

      // æ›´æ–°æ’åè¡¨æ ¼
      const tbody = document.querySelector('#detailedRankingTable tbody');
      tbody.innerHTML = '';

      sortedRunners.forEach((runner, index) => {
        const row = tbody.insertRow();
        row.className = index < 3 ? ['gold', 'silver', 'bronze'][index] : '';
        
        // æ„å»ºæ£€æŸ¥ç‚¹æ—¶é—´å•å…ƒæ ¼
        const orderedCheckpoints = checkpoints.sort((a, b) => a.order_index - b.order_index);
        let checkpointsHtml = '';
        
        orderedCheckpoints.forEach(cp => {
          if (checkpointFilter === 'all' || cp.code === checkpointFilter) {
            const checkpointData = runner.checkpoints[cp.code];
            checkpointsHtml += `<div>${cp.name}: ${checkpointData ? checkpointData.formatted_time : '-'}</div>`;
          }
        });

        row.innerHTML = `
          <td>${index + 1} ${index < 3 ? ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰'][index] : ''}</td>
          <td>${runner.bib_number}</td>
          <td>${runner.name}</td>
          <td>${checkpointsHtml}</td>
          <td>${runner.total_time || '-'}</td>
        `;
      });
    }

    // åŠ è½½æ‰“å¡è®°å½•æ•°æ®
    function loadCheckinsData() {
      if (!adminClient) return;
      
      // è·å–æ‰€æœ‰äº‹ä»¶æ•°æ®
      adminClient
        .from('events')
        .select('*')
        .order('timestamp', { ascending: false })
        .then(({ data: events, error: e1 }) => {
          if (e1) throw e1;
          
          return adminClient
            .from('participants')
            .select('*')
            .then(({ data: participants, error: e2 }) => {
              if (e2) throw e2;
              
              // æ˜¾ç¤ºæ‰“å¡è®°å½•
              displayCheckins(events, participants);
            });
        })
        .catch(error => {
          console.error('åŠ è½½æ‰“å¡è®°å½•å¤±è´¥:', error);
          alert('åŠ è½½æ‰“å¡è®°å½•å¤±è´¥: ' + error.message);
        });
    }

    // æ˜¾ç¤ºæ‰“å¡è®°å½•
    function displayCheckins(events, participants) {
      const tbody = document.querySelector('#checkinsTable tbody');
      tbody.innerHTML = '';
      
      // åˆ›å»ºå‚èµ›è€…æ˜ å°„è¡¨
      const participantMap = {};
      participants.forEach(p => {
        participantMap[p.bib_number] = p.name;
      });
      
      // åˆ›å»ºæ£€æŸ¥ç‚¹åç§°æ˜ å°„è¡¨
      const checkpointMap = {};
      checkpoints.forEach(cp => {
        checkpointMap[cp.code] = cp.name;
      });
      
      // æ˜¾ç¤ºå‰100æ¡è®°å½•
      const eventsToShow = events.slice(0, 100);
      
      eventsToShow.forEach(event => {
        const row = tbody.insertRow();
        row.innerHTML = `
          <td>${formatDateTime(event.timestamp)}</td>
          <td>${event.bib_number}</td>
          <td>${participantMap[event.bib_number] || 'æœªçŸ¥'}</td>
          <td>${checkpointMap[event.checkpoint] || event.checkpoint}</td>
        `;
      });
    }

    // ç­›é€‰æ‰“å¡è®°å½•
    function filterCheckins() {
      const checkpointFilter = document.getElementById('checkpointFilter').value;
      const bibFilter = document.getElementById('bibFilter').value.toLowerCase();
      const rows = document.querySelectorAll('#checkinsTable tbody tr');
      
      rows.forEach(row => {
        const bib = row.cells[1].textContent.toLowerCase();
        const checkpoint = row.cells[3].textContent;
        
        const checkpointMatch = checkpointFilter === 'all' || 
          checkpoints.some(cp => 
            cp.name === checkpoint && cp.code === checkpointFilter
          );
        const bibMatch = bib.includes(bibFilter);
        
        row.style.display = checkpointMatch && bibMatch ? '' : 'none';
      });
    }

    function displayResults(events, participants) {
      const bibStats = {};
      const startCheckpoint = checkpoints.find(cp => cp.code === 'START') || checkpoints[0];
      const finishCheckpoint = checkpoints.find(cp => cp.code === 'FINISH') || checkpoints[checkpoints.length - 1];

      events.forEach(event => {
        if (!bibStats[event.bib_number]) {
          bibStats[event.bib_number] = {
            bib_number: event.bib_number,
            name: (participants.find(p => p.bib_number === event.bib_number) || {}).name || 'æœªçŸ¥',
            start_time: null,
            finish_time: null,
            duration_ms: null,
            duration: null
          };
        }
        if (event.checkpoint === startCheckpoint.code) {
          bibStats[event.bib_number].start_time = event.timestamp;
        } else if (event.checkpoint === finishCheckpoint.code) {
          bibStats[event.bib_number].finish_time = event.timestamp;
        }
      });

      // è®¡ç®—å®Œæˆæ—¶é—´
      Object.values(bibStats).forEach(runner => {
        if (runner.start_time && runner.finish_time) {
          const startTime = new Date(runner.start_time);
          const finishTime = new Date(runner.finish_time);
          
          // ç¡®ä¿å¼€å§‹æ—¶é—´åœ¨ç»“æŸæ—¶é—´ä¹‹å‰
          if (finishTime >= startTime) {
            const duration = finishTime - startTime;
            runner.duration_ms = duration;
            runner.duration = formatDuration(duration);
          } else {
            // å¦‚æœç»“æŸæ—¶é—´æ—©äºå¼€å§‹æ—¶é—´ï¼Œå¯èƒ½æ˜¯è·¨å¤©æˆ–æ—¶åŒºé—®é¢˜
            const duration = (finishTime.getTime() + 24 * 60 * 60 * 1000) - startTime.getTime();
            runner.duration_ms = duration;
            runner.duration = formatDuration(duration);
          }
        }
      });

      // æ ¹æ®æ’åæ¨¡å¼æ’åº
      let sortedRunners;
      if (rankingMode === 'gun') {
        sortedRunners = Object.values(bibStats)
          .filter(r => r.finish_time)
          .sort((a, b) => new Date(a.finish_time) - new Date(b.finish_time));
      } else {
        sortedRunners = Object.values(bibStats)
          .filter(r => r.duration_ms)
          .sort((a, b) => a.duration_ms - b.duration_ms);
      }

      // æ›´æ–°è¡¨æ ¼
      const tbody = document.querySelector('#resultsTable tbody');
      tbody.innerHTML = '';

      sortedRunners.slice(0, 200).forEach((runner, index) => {
        const row = tbody.insertRow();
        row.className = index < 3 ? ['gold', 'silver', 'bronze'][index] : '';

        row.innerHTML = `
          <td>${index + 1} ${index < 3 ? ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰'][index] : ''}</td>
          <td>${runner.bib_number}</td>
          <td>${runner.name}</td>
          <td>${runner.start_time ? formatDateTime(runner.start_time) : '-'}</td>
          <td>${runner.finish_time ? formatDateTime(runner.finish_time) : '-'}</td>
          <td>${runner.duration || '-'}</td>
        `;
      });
    }

    function formatDuration(ms) {
      if (typeof ms !== 'number' || isNaN(ms) || ms < 0) {
        return 'æ— æ•ˆæ—¶é—´';
      }
      
      const secs = Math.floor(ms / 1000);
      const mins = Math.floor(secs / 60);
      const hours = Math.floor(mins / 60);
      
      if (hours > 0) return hours + ':' + String(mins%60).padStart(2,'0') + ':' + String(secs%60).padStart(2,'0');
      if (mins > 0) return mins + ':' + String(secs%60).padStart(2,'0');
      return secs + 'ç§’';
    }
    
    // æ ¼å¼åŒ–æ—¥æœŸæ—¶é—´ï¼Œä¿®å¤æ—¶åŒºæ˜¾ç¤ºé—®é¢˜
    function formatDateTime(timestamp) {
      try {
        const date = new Date(timestamp);
        
        if (isNaN(date.getTime())) {
          console.error(`æ— æ•ˆçš„æ—¶é—´æˆ³: ${timestamp}`);
          return 'æ— æ•ˆæ—¶é—´';
        }
        
        // è°ƒæ•´æ—¶åŒº
        const utcTime = date.getTime();
        const adjustedTime = utcTime + (8 * 60 * 60 * 1000); // æ·»åŠ 8å°æ—¶
        const adjustedDate = new Date(adjustedTime);
        
        const year = adjustedDate.getFullYear();
        const month = String(adjustedDate.getMonth() + 1).padStart(2, '0');
        const day = String(adjustedDate.getDate()).padStart(2, '0');
        const hours = String(adjustedDate.getHours()).padStart(2, '0');
        const minutes = String(adjustedDate.getMinutes()).padStart(2, '0');
        const seconds = String(adjustedDate.getSeconds()).padStart(2, '0');
        
        return `${year}/${month}/${day} ${hours}:${minutes}:${seconds}`;
      } catch (error) {
        console.error(`æ ¼å¼åŒ–æ—¶é—´æ—¶å‡ºé”™: ${error.message}`);
        return `é”™è¯¯: ${error.message}`;
      }
    }

    function logRecentEvents(events) {
      const recent = events.slice(-10).reverse();
      const log = document.getElementById('log');
      
      // åˆ›å»ºæ£€æŸ¥ç‚¹åç§°æ˜ å°„è¡¨
      const checkpointMap = {};
      checkpoints.forEach(cp => {
        checkpointMap[cp.code] = cp.name;
      });
      
      log.innerHTML = recent.map(e => {
        const adjustedTime = new Date(new Date(e.timestamp).getTime() + (8 * 60 * 60 * 1000));
        const checkpointName = checkpointMap[e.checkpoint] || e.checkpoint;
        const color = e.checkpoint === 'START' ? '#10b981' : e.checkpoint === 'FINISH' ? '#ef4444' : '#3b82f6';
        return `<span style="color: ${color};">
        âœ… ${e.bib_number} ${checkpointName} ${adjustedTime.toLocaleString('zh-HK')}
        </span>`;
      }).join('<br>');
    }

    function updateDashboard(events, participants) {
      const totalRunners = participants.length;
      const startCheckpoint = checkpoints.find(cp => cp.code === 'START') || checkpoints[0];
      const finishCheckpoint = checkpoints.find(cp => cp.code === 'FINISH') || checkpoints[checkpoints.length - 1];
      
      const startedEvents = events.filter(e => e.checkpoint === startCheckpoint.code);
      const finishedEvents = events.filter(e => e.checkpoint === finishCheckpoint.code);
      
      // å»é‡ç»Ÿè®¡å·²å¼€å§‹å’Œå·²å®Œæˆçš„äººæ•°
      const startedBibs = new Set(startedEvents.map(e => e.bib_number));
      const finishedBibs = new Set(finishedEvents.map(e => e.bib_number));
      
      const startedCount = startedBibs.size;
      const finishedCount = finishedBibs.size;
      
      // è®¡ç®—å¹³å‡å®Œæˆæ—¶é—´
      let totalDuration = 0;
      let validFinishCount = 0;
      
      participants.forEach(runner => {
        if (startedBibs.has(runner.bib_number) && finishedBibs.has(runner.bib_number)) {
          const startEvent = startedEvents.find(e => e.bib_number === runner.bib_number);
          const finishEvent = finishedEvents.find(e => e.bib_number === runner.bib_number);
          
          if (startEvent && finishEvent) {
            const startTime = new Date(startEvent.timestamp).getTime();
            const finishTime = new Date(finishEvent.timestamp).getTime();
            const duration = finishTime - startTime;
            
            if (duration > 0 && duration < 24 * 60 * 60 * 1000) {
              totalDuration += duration;
              validFinishCount++;
            }
          }
        }
      });
      
      const avgTime = validFinishCount > 0 ? totalDuration / validFinishCount : 0;
      
      // æ›´æ–°ä»ªè¡¨ç›˜
      document.getElementById('totalRunners').textContent = totalRunners;
      document.getElementById('startedRunners').textContent = startedCount;
      document.getElementById('finishedRunners').textContent = finishedCount;
      document.getElementById('avgTime').textContent = avgTime ? formatDuration(avgTime) : '00:00';
    }

    function updateProgressChart(events, participants) {
      const ctx = document.getElementById('progressChartCanvas').getContext('2d');
      const startCheckpoint = checkpoints.find(cp => cp.code === 'START') || checkpoints[0];
      const finishCheckpoint = checkpoints.find(cp => cp.code === 'FINISH') || checkpoints[checkpoints.length - 1];
      
      // æŒ‰å°æ—¶ç»Ÿè®¡å¼€å§‹å’Œå®Œæˆçš„äººæ•°
      const hourData = {};
      const maxHours = 12; // æœ€å¤šæ˜¾ç¤º12å°æ—¶çš„æ•°æ®
      
      // åˆå§‹åŒ–æ•°æ®
      for (let i = 0; i < maxHours; i++) {
        hourData[i] = { start: 0, finish: 0 };
      }
      
      // å¤„ç†å¼€å§‹äº‹ä»¶
      const startEvents = events.filter(e => e.checkpoint === startCheckpoint.code);
      startEvents.forEach(event => {
        const hour = new Date(event.timestamp).getHours() % maxHours;
        hourData[hour].start++;
      });
      
      // å¤„ç†å®Œæˆäº‹ä»¶
      const finishEvents = events.filter(e => e.checkpoint === finishCheckpoint.code);
      finishEvents.forEach(event => {
        const hour = new Date(event.timestamp).getHours() % maxHours;
        hourData[hour].finish++;
      });
      
      // å‡†å¤‡å›¾è¡¨æ•°æ®
      const labels = Array.from({ length: maxHours }, (_, i) => `${i}:00`);
      const startData = Array.from({ length: maxHours }, (_, i) => hourData[i].start);
      const finishData = Array.from({ length: maxHours }, (_, i) => hourData[i].finish);
      
      // åˆ›å»ºæˆ–æ›´æ–°å›¾è¡¨
      if (progressChart) {
        progressChart.data.labels = labels;
        progressChart.data.datasets[0].data = startData;
        progressChart.data.datasets[1].data = finishData;
        progressChart.update();
      } else {
        progressChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [
              {
                label: 'å¼€å§‹',
                data: startData,
                borderColor: '#10b981',
                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                tension: 0.3,
                fill: true
              },
              {
                label: 'å®Œæˆ',
                data: finishData,
                borderColor: '#ef4444',
                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                tension: 0.3,
                fill: true
              }
            ]
          },
          options: {
            responsive: true,
            plugins: {
              legend: { position: 'top' }
            },
            scales: {
              y: { beginAtZero: true }
            }
          }
        });
      }
    }

    function setMode(mode, event) {
      rankingMode = mode;
      
      // æ›´æ–°æŒ‰é’®çŠ¶æ€
      document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
      if (event && event.target) {
        event.target.classList.add('active');
      }
      
      // åˆ·æ–°æ•°æ®
      refreshData();
    }

    // æ˜¾ç¤ºç®¡ç†å‚èµ›è€…æ¨¡æ€æ¡†
    function showManageUsersModal() {
      if (!adminClient) {
        alert('è¯·å…ˆè¿æ¥æ•°æ®åº“');
        return;
      }
      
      document.getElementById('manageUsersModal').style.display = 'flex';
      loadParticipants();
    }

    // éšè—ç®¡ç†å‚èµ›è€…æ¨¡æ€æ¡†
    function hideManageUsersModal() {
      document.getElementById('manageUsersModal').style.display = 'none';
    }

    // åŠ è½½å‚èµ›è€…åˆ—è¡¨
    async function loadParticipants() {
      if (!adminClient) return;
      
      const { data, error } = await adminClient
        .from('participants')
        .select('*')
        .order('bib_number');
      
      if (error) {
        console.error('åŠ è½½å‚èµ›è€…å¤±è´¥:', error);
        alert('åŠ è½½å‚èµ›è€…å¤±è´¥: ' + error.message);
        return;
      }
      
      const tbody = document.getElementById('participantsTableBody');
      tbody.innerHTML = '';
      
      data.forEach(participant => {
        const row = tbody.insertRow();
        row.innerHTML = `
          <td>${participant.bib_number}</td>
          <td>${participant.name}</td>
          <td>
            <button onclick="deleteParticipant('${participant.bib_number}')" style="background: #ef4444; padding: 4px 8px; font-size: 12px;">åˆ é™¤</button>
          </td>
        `;
      });
    }

    // æ·»åŠ å•ä¸ªå‚èµ›è€…
    async function addSingleUser() {
      if (!adminClient) {
        alert('è¯·å…ˆè¿æ¥æ•°æ®åº“');
        return;
      }
      
      const bib = document.getElementById('manualBibNumber').value.trim();
      const name = document.getElementById('manualName').value.trim();
      
      if (!bib || !name) {
        alert('è¯·å¡«å†™å·ç å’Œå§“å');
        return;
      }
      
      try {
        // æ£€æŸ¥å·ç æ˜¯å¦å·²å­˜åœ¨
        const { data: existing } = await adminClient
          .from('participants')
          .select('*')
          .eq('bib_number', bib)
          .single();
          
        if (existing) {
          alert('è¯¥å·ç å·²å­˜åœ¨');
          return;
        }
      } catch (error) {
        // å¦‚æœæ²¡æœ‰æ‰¾åˆ°è®°å½•ï¼Œerroræ˜¯æ­£å¸¸çš„
        if (error.code !== 'PGRST116') {
          console.error('æ£€æŸ¥å‚èµ›è€…å¤±è´¥:', error);
          alert('æ“ä½œå¤±è´¥: ' + error.message);
          return;
        }
      }
      
      // æ·»åŠ æ–°å‚èµ›è€…
      const { error } = await adminClient
        .from('participants')
        .insert([{ bib_number: bib, name: name }]);
      
      if (error) {
        console.error('æ·»åŠ å‚èµ›è€…å¤±è´¥:', error);
        alert('æ·»åŠ å¤±è´¥: ' + error.message);
      } else {
        alert('æ·»åŠ æˆåŠŸ');
        document.getElementById('manualBibNumber').value = '';
        document.getElementById('manualName').value = '';
        loadParticipants();
      }
    }

    // åˆ é™¤å‚èµ›è€…
    async function deleteParticipant(bibNumber) {
      if (!confirm(`ç¡®å®šè¦åˆ é™¤å·ç ä¸º ${bibNumber} çš„å‚èµ›è€…å—ï¼Ÿ`)) {
        return;
      }
      
      if (!adminClient) {
        alert('è¯·å…ˆè¿æ¥æ•°æ®åº“');
        return;
      }
      
      // å…ˆåˆ é™¤ç›¸å…³äº‹ä»¶
      const { error: eventError } = await adminClient
        .from('events')
        .delete()
        .eq('bib_number', bibNumber);
      
      if (eventError) {
        console.error('åˆ é™¤äº‹ä»¶å¤±è´¥:', eventError);
        alert('åˆ é™¤äº‹ä»¶å¤±è´¥: ' + eventError.message);
        return;
      }
      
      // å†åˆ é™¤å‚èµ›è€…
      const { error } = await adminClient
        .from('participants')
        .delete()
        .eq('bib_number', bibNumber);
      
      if (error) {
        console.error('åˆ é™¤å‚èµ›è€…å¤±è´¥:', error);
        alert('åˆ é™¤å¤±è´¥: ' + error.message);
      } else {
        alert('åˆ é™¤æˆåŠŸ');
        loadParticipants();
      }
    }

    // ä»CSVå¯¼å…¥å‚èµ›è€…
    async function importFromCSV() {
      const fileInput = document.getElementById('csvFileInput');
      const statusElement = document.getElementById('csvImportStatus');
      
      if (!fileInput.files || fileInput.files.length === 0) {
        alert('è¯·é€‰æ‹©CSVæ–‡ä»¶');
        return;
      }
      
      statusElement.textContent = 'æ­£åœ¨è§£æCSVæ–‡ä»¶...';
      
      const file = fileInput.files[0];
      const reader = new FileReader();
      
      reader.onload = async function(e) {
        try {
          const content = e.target.result;
          const lines = content.split('\n');
          const participants = [];
          
          // è§£æCSVå†…å®¹
          for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue;
            
            const [bib, name] = line.split(',');
            if (bib && name) {
              participants.push({
                bib_number: bib.trim(),
                name: name.trim()
              });
            } else {
              statusElement.textContent += `\nè¡Œ ${i+1} æ ¼å¼é”™è¯¯: ${line}`;
            }
          }
          
          if (participants.length === 0) {
            statusElement.textContent += '\næ²¡æœ‰æœ‰æ•ˆçš„å‚èµ›è€…æ•°æ®';
            return;
          }
          
          statusElement.textContent += `\nå‘ç° ${participants.length} ä¸ªå‚èµ›è€…ï¼Œæ­£åœ¨å¯¼å…¥...`;
          
          // æ‰¹é‡å¯¼å…¥
          const { error } = await adminClient
            .from('participants')
            .insert(participants)
            .onConflict('bib_number')
            .ignore(); // å¿½ç•¥å·²å­˜åœ¨çš„å·ç 
          
          if (error) {
            throw new Error(error.message);
          }
          
          statusElement.textContent += '\nå¯¼å…¥å®Œæˆï¼';
          loadParticipants(); // åˆ·æ–°åˆ—è¡¨
          
        } catch (error) {
          statusElement.textContent += `\nå¯¼å…¥å¤±è´¥: ${error.message}`;
          console.error('CSVå¯¼å…¥é”™è¯¯:', error);
        }
      };
      
      reader.readAsText(file);
    }

    // å¯¼å‡ºCSV
    async function exportCSV() {
      if (!adminClient) {
        alert('è¯·å…ˆè¿æ¥æ•°æ®åº“');
        return;
      }
      
      // è·å–æ‰€æœ‰æ•°æ®
      const { data: participants, error: e1 } = await adminClient
        .from('participants')
        .select('*');
      
      if (e1) {
        alert('è·å–å‚èµ›è€…æ•°æ®å¤±è´¥: ' + e1.message);
        return;
      }
      
      const { data: events, error: e2 } = await adminClient
        .from('events')
        .select('*');
      
      if (e2) {
        alert('è·å–äº‹ä»¶æ•°æ®å¤±è´¥: ' + e2.message);
        return;
      }
      
      // å‡†å¤‡CSVå†…å®¹
      let csvContent = 'å·ç ,å§“å';
      
      // æ·»åŠ æ£€æŸ¥ç‚¹åˆ—
      checkpoints.forEach(cp => {
        csvContent += `,${cp.name}`;
      });
      
      csvContent += ',æ€»ç”¨æ—¶\n';
      
      // å¤„ç†æ¯ä¸ªå‚èµ›è€…
      participants.forEach(participant => {
        const row = [participant.bib_number, participant.name];
        
        // æ”¶é›†æ¯ä¸ªæ£€æŸ¥ç‚¹çš„æ—¶é—´
        const checkpointTimes = {};
        events.forEach(event => {
          if (event.bib_number === participant.bib_number) {
            checkpointTimes[event.checkpoint] = formatDateTime(event.timestamp);
          }
        });
        
        // æ·»åŠ æ£€æŸ¥ç‚¹æ—¶é—´
        checkpoints.forEach(cp => {
          row.push(checkpointTimes[cp.code] || '');
        });
        
        // è®¡ç®—æ€»ç”¨æ—¶
        const startCheckpoint = checkpoints[0];
        const finishCheckpoint = checkpoints[checkpoints.length - 1];
        
        if (checkpointTimes[startCheckpoint.code] && checkpointTimes[finishCheckpoint.code]) {
          const startTime = new Date(events.find(e => e.bib_number === participant.bib_number && e.checkpoint === startCheckpoint.code).timestamp);
          const finishTime = new Date(events.find(e => e.bib_number === participant.bib_number && e.checkpoint === finishCheckpoint.code).timestamp);
          const duration = finishTime - startTime;
          row.push(formatDuration(duration));
        } else {
          row.push('');
        }
        
        csvContent += row.map(cell => `"${cell.replace(/"/g, '""')}"`).join(',') + '\n';
      });
      
      // åˆ›å»ºå¹¶ä¸‹è½½CSVæ–‡ä»¶
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.setAttribute('href', url);
      link.setAttribute('download', `race_results_${new Date().toISOString().slice(0,10)}.csv`);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    // æ¸…ç©ºæ‰€æœ‰æ•°æ®
    async function clearAllData() {
      if (!confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼')) {
        return;
      }
      
      if (!adminClient) {
        alert('è¯·å…ˆè¿æ¥æ•°æ®åº“');
        return;
      }
      
      try {
        // å…ˆåˆ é™¤äº‹ä»¶æ•°æ®
        const { error: e1 } = await adminClient
          .from('events')
          .delete()
          .neq('id', ''); // åˆ é™¤æ‰€æœ‰è®°å½•
        
        if (e1) throw e1;
        
        // å†åˆ é™¤å‚èµ›è€…æ•°æ®
        const { error: e2 } = await adminClient
          .from('participants')
          .delete()
          .neq('id', ''); // åˆ é™¤æ‰€æœ‰è®°å½•
        
        if (e2) throw e2;
        
        alert('æ‰€æœ‰æ•°æ®å·²æ¸…ç©º');
        refreshData();
        
      } catch (error) {
        console.error('æ¸…ç©ºæ•°æ®å¤±è´¥:', error);
        alert('æ¸…ç©ºæ•°æ®å¤±è´¥: ' + error.message);
      }
    }
  </script>
</body>
</html>
